// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AMMOTEXTFB_FBAMMO_H_
#define FLATBUFFERS_GENERATED_AMMOTEXTFB_FBAMMO_H_

#include "flatbuffers/flatbuffers.h"

#include "languageBundleFB_generated.h"

namespace fbAmmo {

struct FB_AmmoTextCommon;
struct FB_AmmoTextCommonBuilder;

struct FB_AmmoText;
struct FB_AmmoTextBuilder;

struct FB_AmmoTextCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_AmmoTextCommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_TYPE = 4,
    VT_QUANTITY = 6
  };
  const fbCommon::FB_LanguageBundle *item_type() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_ITEM_TYPE);
  }
  const fbCommon::FB_LanguageBundle *quantity() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_QUANTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEM_TYPE) &&
           verifier.VerifyTable(item_type()) &&
           VerifyOffset(verifier, VT_QUANTITY) &&
           verifier.VerifyTable(quantity()) &&
           verifier.EndTable();
  }
};

struct FB_AmmoTextCommonBuilder {
  typedef FB_AmmoTextCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_type(flatbuffers::Offset<fbCommon::FB_LanguageBundle> item_type) {
    fbb_.AddOffset(FB_AmmoTextCommon::VT_ITEM_TYPE, item_type);
  }
  void add_quantity(flatbuffers::Offset<fbCommon::FB_LanguageBundle> quantity) {
    fbb_.AddOffset(FB_AmmoTextCommon::VT_QUANTITY, quantity);
  }
  explicit FB_AmmoTextCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_AmmoTextCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_AmmoTextCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_AmmoTextCommon> CreateFB_AmmoTextCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> item_type = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> quantity = 0) {
  FB_AmmoTextCommonBuilder builder_(_fbb);
  builder_.add_quantity(quantity);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct FB_AmmoText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_AmmoTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4
  };
  const fbAmmo::FB_AmmoTextCommon *common() const {
    return GetPointer<const fbAmmo::FB_AmmoTextCommon *>(VT_COMMON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           verifier.EndTable();
  }
};

struct FB_AmmoTextBuilder {
  typedef FB_AmmoText Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_common(flatbuffers::Offset<fbAmmo::FB_AmmoTextCommon> common) {
    fbb_.AddOffset(FB_AmmoText::VT_COMMON, common);
  }
  explicit FB_AmmoTextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_AmmoText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_AmmoText>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_AmmoText> CreateFB_AmmoText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fbAmmo::FB_AmmoTextCommon> common = 0) {
  FB_AmmoTextBuilder builder_(_fbb);
  builder_.add_common(common);
  return builder_.Finish();
}

inline const fbAmmo::FB_AmmoText *GetFB_AmmoText(const void *buf) {
  return flatbuffers::GetRoot<fbAmmo::FB_AmmoText>(buf);
}

inline const fbAmmo::FB_AmmoText *GetSizePrefixedFB_AmmoText(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<fbAmmo::FB_AmmoText>(buf);
}

inline const char *FB_AmmoTextIdentifier() {
  return "AMMT";
}

inline bool FB_AmmoTextBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, FB_AmmoTextIdentifier());
}

inline bool VerifyFB_AmmoTextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbAmmo::FB_AmmoText>(FB_AmmoTextIdentifier());
}

inline bool VerifySizePrefixedFB_AmmoTextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbAmmo::FB_AmmoText>(FB_AmmoTextIdentifier());
}

inline const char *FB_AmmoTextExtension() {
  return "bundle";
}

inline void FinishFB_AmmoTextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbAmmo::FB_AmmoText> root) {
  fbb.Finish(root, FB_AmmoTextIdentifier());
}

inline void FinishSizePrefixedFB_AmmoTextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbAmmo::FB_AmmoText> root) {
  fbb.FinishSizePrefixed(root, FB_AmmoTextIdentifier());
}

}  // namespace fbAmmo

#endif  // FLATBUFFERS_GENERATED_AMMOTEXTFB_FBAMMO_H_
