// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEAPONTEXTFB_FBWEAPON_H_
#define FLATBUFFERS_GENERATED_WEAPONTEXTFB_FBWEAPON_H_

#include "flatbuffers/flatbuffers.h"

#include "languageBundleFB_generated.h"

namespace fbWeapon {

struct FB_WeaponTextType;
struct FB_WeaponTextTypeBuilder;

struct FB_WeaponTextPenalties;
struct FB_WeaponTextPenaltiesBuilder;

struct FB_WeaponTextCommon;
struct FB_WeaponTextCommonBuilder;

struct FB_WeaponText;
struct FB_WeaponTextBuilder;

struct FB_WeaponTextType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_WeaponTextTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AR = 4,
    VT_SMG = 6,
    VT_SA_PISTOL = 8,
    VT_REVOLVER = 10,
    VT_AUTO_SHOTGUN = 12,
    VT_PUMP_SHOTGUN = 14,
    VT_SR = 16,
    VT_FLAMETHROWER = 18,
    VT_HMG = 20,
    VT_ROCKET = 22,
    VT_LASER = 24,
    VT_BLADED = 26,
    VT_BLUNT = 28,
    VT_BRAWLING = 30
  };
  const fbCommon::FB_LanguageBundle *ar() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_AR);
  }
  const fbCommon::FB_LanguageBundle *smg() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_SMG);
  }
  const fbCommon::FB_LanguageBundle *sa_pistol() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_SA_PISTOL);
  }
  const fbCommon::FB_LanguageBundle *revolver() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_REVOLVER);
  }
  const fbCommon::FB_LanguageBundle *auto_shotgun() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_AUTO_SHOTGUN);
  }
  const fbCommon::FB_LanguageBundle *pump_shotgun() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_PUMP_SHOTGUN);
  }
  const fbCommon::FB_LanguageBundle *sr() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_SR);
  }
  const fbCommon::FB_LanguageBundle *flamethrower() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_FLAMETHROWER);
  }
  const fbCommon::FB_LanguageBundle *hmg() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_HMG);
  }
  const fbCommon::FB_LanguageBundle *rocket() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_ROCKET);
  }
  const fbCommon::FB_LanguageBundle *laser() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_LASER);
  }
  const fbCommon::FB_LanguageBundle *bladed() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BLADED);
  }
  const fbCommon::FB_LanguageBundle *blunt() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BLUNT);
  }
  const fbCommon::FB_LanguageBundle *brawling() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BRAWLING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AR) &&
           verifier.VerifyTable(ar()) &&
           VerifyOffset(verifier, VT_SMG) &&
           verifier.VerifyTable(smg()) &&
           VerifyOffset(verifier, VT_SA_PISTOL) &&
           verifier.VerifyTable(sa_pistol()) &&
           VerifyOffset(verifier, VT_REVOLVER) &&
           verifier.VerifyTable(revolver()) &&
           VerifyOffset(verifier, VT_AUTO_SHOTGUN) &&
           verifier.VerifyTable(auto_shotgun()) &&
           VerifyOffset(verifier, VT_PUMP_SHOTGUN) &&
           verifier.VerifyTable(pump_shotgun()) &&
           VerifyOffset(verifier, VT_SR) &&
           verifier.VerifyTable(sr()) &&
           VerifyOffset(verifier, VT_FLAMETHROWER) &&
           verifier.VerifyTable(flamethrower()) &&
           VerifyOffset(verifier, VT_HMG) &&
           verifier.VerifyTable(hmg()) &&
           VerifyOffset(verifier, VT_ROCKET) &&
           verifier.VerifyTable(rocket()) &&
           VerifyOffset(verifier, VT_LASER) &&
           verifier.VerifyTable(laser()) &&
           VerifyOffset(verifier, VT_BLADED) &&
           verifier.VerifyTable(bladed()) &&
           VerifyOffset(verifier, VT_BLUNT) &&
           verifier.VerifyTable(blunt()) &&
           VerifyOffset(verifier, VT_BRAWLING) &&
           verifier.VerifyTable(brawling()) &&
           verifier.EndTable();
  }
};

struct FB_WeaponTextTypeBuilder {
  typedef FB_WeaponTextType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ar(flatbuffers::Offset<fbCommon::FB_LanguageBundle> ar) {
    fbb_.AddOffset(FB_WeaponTextType::VT_AR, ar);
  }
  void add_smg(flatbuffers::Offset<fbCommon::FB_LanguageBundle> smg) {
    fbb_.AddOffset(FB_WeaponTextType::VT_SMG, smg);
  }
  void add_sa_pistol(flatbuffers::Offset<fbCommon::FB_LanguageBundle> sa_pistol) {
    fbb_.AddOffset(FB_WeaponTextType::VT_SA_PISTOL, sa_pistol);
  }
  void add_revolver(flatbuffers::Offset<fbCommon::FB_LanguageBundle> revolver) {
    fbb_.AddOffset(FB_WeaponTextType::VT_REVOLVER, revolver);
  }
  void add_auto_shotgun(flatbuffers::Offset<fbCommon::FB_LanguageBundle> auto_shotgun) {
    fbb_.AddOffset(FB_WeaponTextType::VT_AUTO_SHOTGUN, auto_shotgun);
  }
  void add_pump_shotgun(flatbuffers::Offset<fbCommon::FB_LanguageBundle> pump_shotgun) {
    fbb_.AddOffset(FB_WeaponTextType::VT_PUMP_SHOTGUN, pump_shotgun);
  }
  void add_sr(flatbuffers::Offset<fbCommon::FB_LanguageBundle> sr) {
    fbb_.AddOffset(FB_WeaponTextType::VT_SR, sr);
  }
  void add_flamethrower(flatbuffers::Offset<fbCommon::FB_LanguageBundle> flamethrower) {
    fbb_.AddOffset(FB_WeaponTextType::VT_FLAMETHROWER, flamethrower);
  }
  void add_hmg(flatbuffers::Offset<fbCommon::FB_LanguageBundle> hmg) {
    fbb_.AddOffset(FB_WeaponTextType::VT_HMG, hmg);
  }
  void add_rocket(flatbuffers::Offset<fbCommon::FB_LanguageBundle> rocket) {
    fbb_.AddOffset(FB_WeaponTextType::VT_ROCKET, rocket);
  }
  void add_laser(flatbuffers::Offset<fbCommon::FB_LanguageBundle> laser) {
    fbb_.AddOffset(FB_WeaponTextType::VT_LASER, laser);
  }
  void add_bladed(flatbuffers::Offset<fbCommon::FB_LanguageBundle> bladed) {
    fbb_.AddOffset(FB_WeaponTextType::VT_BLADED, bladed);
  }
  void add_blunt(flatbuffers::Offset<fbCommon::FB_LanguageBundle> blunt) {
    fbb_.AddOffset(FB_WeaponTextType::VT_BLUNT, blunt);
  }
  void add_brawling(flatbuffers::Offset<fbCommon::FB_LanguageBundle> brawling) {
    fbb_.AddOffset(FB_WeaponTextType::VT_BRAWLING, brawling);
  }
  explicit FB_WeaponTextTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_WeaponTextType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_WeaponTextType>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_WeaponTextType> CreateFB_WeaponTextType(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> ar = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> smg = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> sa_pistol = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> revolver = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> auto_shotgun = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> pump_shotgun = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> sr = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> flamethrower = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> hmg = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> rocket = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> laser = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> bladed = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> blunt = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> brawling = 0) {
  FB_WeaponTextTypeBuilder builder_(_fbb);
  builder_.add_brawling(brawling);
  builder_.add_blunt(blunt);
  builder_.add_bladed(bladed);
  builder_.add_laser(laser);
  builder_.add_rocket(rocket);
  builder_.add_hmg(hmg);
  builder_.add_flamethrower(flamethrower);
  builder_.add_sr(sr);
  builder_.add_pump_shotgun(pump_shotgun);
  builder_.add_auto_shotgun(auto_shotgun);
  builder_.add_revolver(revolver);
  builder_.add_sa_pistol(sa_pistol);
  builder_.add_smg(smg);
  builder_.add_ar(ar);
  return builder_.Finish();
}

struct FB_WeaponTextPenalties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_WeaponTextPenaltiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CRIT_DAMAGE = 4,
    VT_HIT_CHANCE = 6,
    VT_CRIT_CHANCE = 8,
    VT_STRIKE_RATE = 10
  };
  const fbCommon::FB_LanguageBundle *crit_damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_CRIT_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *hit_chance() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_HIT_CHANCE);
  }
  const fbCommon::FB_LanguageBundle *crit_chance() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_CRIT_CHANCE);
  }
  const fbCommon::FB_LanguageBundle *strike_rate() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_STRIKE_RATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CRIT_DAMAGE) &&
           verifier.VerifyTable(crit_damage()) &&
           VerifyOffset(verifier, VT_HIT_CHANCE) &&
           verifier.VerifyTable(hit_chance()) &&
           VerifyOffset(verifier, VT_CRIT_CHANCE) &&
           verifier.VerifyTable(crit_chance()) &&
           VerifyOffset(verifier, VT_STRIKE_RATE) &&
           verifier.VerifyTable(strike_rate()) &&
           verifier.EndTable();
  }
};

struct FB_WeaponTextPenaltiesBuilder {
  typedef FB_WeaponTextPenalties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_crit_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_damage) {
    fbb_.AddOffset(FB_WeaponTextPenalties::VT_CRIT_DAMAGE, crit_damage);
  }
  void add_hit_chance(flatbuffers::Offset<fbCommon::FB_LanguageBundle> hit_chance) {
    fbb_.AddOffset(FB_WeaponTextPenalties::VT_HIT_CHANCE, hit_chance);
  }
  void add_crit_chance(flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_chance) {
    fbb_.AddOffset(FB_WeaponTextPenalties::VT_CRIT_CHANCE, crit_chance);
  }
  void add_strike_rate(flatbuffers::Offset<fbCommon::FB_LanguageBundle> strike_rate) {
    fbb_.AddOffset(FB_WeaponTextPenalties::VT_STRIKE_RATE, strike_rate);
  }
  explicit FB_WeaponTextPenaltiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_WeaponTextPenalties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_WeaponTextPenalties>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_WeaponTextPenalties> CreateFB_WeaponTextPenalties(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> hit_chance = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_chance = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> strike_rate = 0) {
  FB_WeaponTextPenaltiesBuilder builder_(_fbb);
  builder_.add_strike_rate(strike_rate);
  builder_.add_crit_chance(crit_chance);
  builder_.add_hit_chance(hit_chance);
  builder_.add_crit_damage(crit_damage);
  return builder_.Finish();
}

struct FB_WeaponTextCommon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_WeaponTextCommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_TYPE = 4,
    VT_LEVEL = 6,
    VT_DAMAGE = 8,
    VT_AP = 10,
    VT_AP_RELOAD = 12,
    VT_REQUIRE = 14,
    VT_INSTALLED_MODS = 16,
    VT_AMMO_CAPACITY = 18,
    VT_AMMO_TYPE = 20,
    VT_FAILED_REQ_PENALTY = 22,
    VT_BASE_HIT_CHANCE = 24,
    VT_CRIT_DAMAGE = 26,
    VT_CRIT_CHANCE = 28,
    VT_BONUS_SNEAK_DAMAGE = 30,
    VT_BONUS_NORM_DAMAGE = 32,
    VT_BONUS_MELEE_DAMAGE = 34,
    VT_BONUS_RANGE_DAMAGE = 36,
    VT_PENETRATION = 38
  };
  const fbCommon::FB_LanguageBundle *item_type() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_ITEM_TYPE);
  }
  const fbCommon::FB_LanguageBundle *level() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_LEVEL);
  }
  const fbCommon::FB_LanguageBundle *damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *ap() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_AP);
  }
  const fbCommon::FB_LanguageBundle *ap_reload() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_AP_RELOAD);
  }
  const fbCommon::FB_LanguageBundle *require() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_REQUIRE);
  }
  const fbCommon::FB_LanguageBundle *installed_mods() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_INSTALLED_MODS);
  }
  const fbCommon::FB_LanguageBundle *ammo_capacity() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_AMMO_CAPACITY);
  }
  const fbCommon::FB_LanguageBundle *ammo_type() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_AMMO_TYPE);
  }
  const fbCommon::FB_LanguageBundle *failed_req_penalty() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_FAILED_REQ_PENALTY);
  }
  const fbCommon::FB_LanguageBundle *base_hit_chance() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BASE_HIT_CHANCE);
  }
  const fbCommon::FB_LanguageBundle *crit_damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_CRIT_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *crit_chance() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_CRIT_CHANCE);
  }
  const fbCommon::FB_LanguageBundle *bonus_sneak_damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BONUS_SNEAK_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *bonus_norm_damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BONUS_NORM_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *bonus_melee_damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BONUS_MELEE_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *bonus_range_damage() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_BONUS_RANGE_DAMAGE);
  }
  const fbCommon::FB_LanguageBundle *penetration() const {
    return GetPointer<const fbCommon::FB_LanguageBundle *>(VT_PENETRATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEM_TYPE) &&
           verifier.VerifyTable(item_type()) &&
           VerifyOffset(verifier, VT_LEVEL) &&
           verifier.VerifyTable(level()) &&
           VerifyOffset(verifier, VT_DAMAGE) &&
           verifier.VerifyTable(damage()) &&
           VerifyOffset(verifier, VT_AP) &&
           verifier.VerifyTable(ap()) &&
           VerifyOffset(verifier, VT_AP_RELOAD) &&
           verifier.VerifyTable(ap_reload()) &&
           VerifyOffset(verifier, VT_REQUIRE) &&
           verifier.VerifyTable(require()) &&
           VerifyOffset(verifier, VT_INSTALLED_MODS) &&
           verifier.VerifyTable(installed_mods()) &&
           VerifyOffset(verifier, VT_AMMO_CAPACITY) &&
           verifier.VerifyTable(ammo_capacity()) &&
           VerifyOffset(verifier, VT_AMMO_TYPE) &&
           verifier.VerifyTable(ammo_type()) &&
           VerifyOffset(verifier, VT_FAILED_REQ_PENALTY) &&
           verifier.VerifyTable(failed_req_penalty()) &&
           VerifyOffset(verifier, VT_BASE_HIT_CHANCE) &&
           verifier.VerifyTable(base_hit_chance()) &&
           VerifyOffset(verifier, VT_CRIT_DAMAGE) &&
           verifier.VerifyTable(crit_damage()) &&
           VerifyOffset(verifier, VT_CRIT_CHANCE) &&
           verifier.VerifyTable(crit_chance()) &&
           VerifyOffset(verifier, VT_BONUS_SNEAK_DAMAGE) &&
           verifier.VerifyTable(bonus_sneak_damage()) &&
           VerifyOffset(verifier, VT_BONUS_NORM_DAMAGE) &&
           verifier.VerifyTable(bonus_norm_damage()) &&
           VerifyOffset(verifier, VT_BONUS_MELEE_DAMAGE) &&
           verifier.VerifyTable(bonus_melee_damage()) &&
           VerifyOffset(verifier, VT_BONUS_RANGE_DAMAGE) &&
           verifier.VerifyTable(bonus_range_damage()) &&
           VerifyOffset(verifier, VT_PENETRATION) &&
           verifier.VerifyTable(penetration()) &&
           verifier.EndTable();
  }
};

struct FB_WeaponTextCommonBuilder {
  typedef FB_WeaponTextCommon Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_type(flatbuffers::Offset<fbCommon::FB_LanguageBundle> item_type) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_ITEM_TYPE, item_type);
  }
  void add_level(flatbuffers::Offset<fbCommon::FB_LanguageBundle> level) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_LEVEL, level);
  }
  void add_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> damage) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_DAMAGE, damage);
  }
  void add_ap(flatbuffers::Offset<fbCommon::FB_LanguageBundle> ap) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_AP, ap);
  }
  void add_ap_reload(flatbuffers::Offset<fbCommon::FB_LanguageBundle> ap_reload) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_AP_RELOAD, ap_reload);
  }
  void add_require(flatbuffers::Offset<fbCommon::FB_LanguageBundle> require) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_REQUIRE, require);
  }
  void add_installed_mods(flatbuffers::Offset<fbCommon::FB_LanguageBundle> installed_mods) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_INSTALLED_MODS, installed_mods);
  }
  void add_ammo_capacity(flatbuffers::Offset<fbCommon::FB_LanguageBundle> ammo_capacity) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_AMMO_CAPACITY, ammo_capacity);
  }
  void add_ammo_type(flatbuffers::Offset<fbCommon::FB_LanguageBundle> ammo_type) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_AMMO_TYPE, ammo_type);
  }
  void add_failed_req_penalty(flatbuffers::Offset<fbCommon::FB_LanguageBundle> failed_req_penalty) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_FAILED_REQ_PENALTY, failed_req_penalty);
  }
  void add_base_hit_chance(flatbuffers::Offset<fbCommon::FB_LanguageBundle> base_hit_chance) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_BASE_HIT_CHANCE, base_hit_chance);
  }
  void add_crit_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_damage) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_CRIT_DAMAGE, crit_damage);
  }
  void add_crit_chance(flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_chance) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_CRIT_CHANCE, crit_chance);
  }
  void add_bonus_sneak_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_sneak_damage) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_BONUS_SNEAK_DAMAGE, bonus_sneak_damage);
  }
  void add_bonus_norm_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_norm_damage) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_BONUS_NORM_DAMAGE, bonus_norm_damage);
  }
  void add_bonus_melee_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_melee_damage) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_BONUS_MELEE_DAMAGE, bonus_melee_damage);
  }
  void add_bonus_range_damage(flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_range_damage) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_BONUS_RANGE_DAMAGE, bonus_range_damage);
  }
  void add_penetration(flatbuffers::Offset<fbCommon::FB_LanguageBundle> penetration) {
    fbb_.AddOffset(FB_WeaponTextCommon::VT_PENETRATION, penetration);
  }
  explicit FB_WeaponTextCommonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_WeaponTextCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_WeaponTextCommon>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_WeaponTextCommon> CreateFB_WeaponTextCommon(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> item_type = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> level = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> ap = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> ap_reload = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> require = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> installed_mods = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> ammo_capacity = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> ammo_type = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> failed_req_penalty = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> base_hit_chance = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> crit_chance = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_sneak_damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_norm_damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_melee_damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> bonus_range_damage = 0,
    flatbuffers::Offset<fbCommon::FB_LanguageBundle> penetration = 0) {
  FB_WeaponTextCommonBuilder builder_(_fbb);
  builder_.add_penetration(penetration);
  builder_.add_bonus_range_damage(bonus_range_damage);
  builder_.add_bonus_melee_damage(bonus_melee_damage);
  builder_.add_bonus_norm_damage(bonus_norm_damage);
  builder_.add_bonus_sneak_damage(bonus_sneak_damage);
  builder_.add_crit_chance(crit_chance);
  builder_.add_crit_damage(crit_damage);
  builder_.add_base_hit_chance(base_hit_chance);
  builder_.add_failed_req_penalty(failed_req_penalty);
  builder_.add_ammo_type(ammo_type);
  builder_.add_ammo_capacity(ammo_capacity);
  builder_.add_installed_mods(installed_mods);
  builder_.add_require(require);
  builder_.add_ap_reload(ap_reload);
  builder_.add_ap(ap);
  builder_.add_damage(damage);
  builder_.add_level(level);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct FB_WeaponText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_WeaponTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PENALTIES = 6,
    VT_COMMON = 8
  };
  const fbWeapon::FB_WeaponTextType *type() const {
    return GetPointer<const fbWeapon::FB_WeaponTextType *>(VT_TYPE);
  }
  const fbWeapon::FB_WeaponTextPenalties *penalties() const {
    return GetPointer<const fbWeapon::FB_WeaponTextPenalties *>(VT_PENALTIES);
  }
  const fbWeapon::FB_WeaponTextCommon *common() const {
    return GetPointer<const fbWeapon::FB_WeaponTextCommon *>(VT_COMMON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_PENALTIES) &&
           verifier.VerifyTable(penalties()) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           verifier.EndTable();
  }
};

struct FB_WeaponTextBuilder {
  typedef FB_WeaponText Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<fbWeapon::FB_WeaponTextType> type) {
    fbb_.AddOffset(FB_WeaponText::VT_TYPE, type);
  }
  void add_penalties(flatbuffers::Offset<fbWeapon::FB_WeaponTextPenalties> penalties) {
    fbb_.AddOffset(FB_WeaponText::VT_PENALTIES, penalties);
  }
  void add_common(flatbuffers::Offset<fbWeapon::FB_WeaponTextCommon> common) {
    fbb_.AddOffset(FB_WeaponText::VT_COMMON, common);
  }
  explicit FB_WeaponTextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_WeaponText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_WeaponText>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_WeaponText> CreateFB_WeaponText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<fbWeapon::FB_WeaponTextType> type = 0,
    flatbuffers::Offset<fbWeapon::FB_WeaponTextPenalties> penalties = 0,
    flatbuffers::Offset<fbWeapon::FB_WeaponTextCommon> common = 0) {
  FB_WeaponTextBuilder builder_(_fbb);
  builder_.add_common(common);
  builder_.add_penalties(penalties);
  builder_.add_type(type);
  return builder_.Finish();
}

inline const fbWeapon::FB_WeaponText *GetFB_WeaponText(const void *buf) {
  return flatbuffers::GetRoot<fbWeapon::FB_WeaponText>(buf);
}

inline const fbWeapon::FB_WeaponText *GetSizePrefixedFB_WeaponText(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<fbWeapon::FB_WeaponText>(buf);
}

inline const char *FB_WeaponTextIdentifier() {
  return "WPNT";
}

inline bool FB_WeaponTextBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, FB_WeaponTextIdentifier());
}

inline bool VerifyFB_WeaponTextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbWeapon::FB_WeaponText>(FB_WeaponTextIdentifier());
}

inline bool VerifySizePrefixedFB_WeaponTextBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbWeapon::FB_WeaponText>(FB_WeaponTextIdentifier());
}

inline const char *FB_WeaponTextExtension() {
  return "bundle";
}

inline void FinishFB_WeaponTextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbWeapon::FB_WeaponText> root) {
  fbb.Finish(root, FB_WeaponTextIdentifier());
}

inline void FinishSizePrefixedFB_WeaponTextBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fbWeapon::FB_WeaponText> root) {
  fbb.FinishSizePrefixed(root, FB_WeaponTextIdentifier());
}

}  // namespace fbWeapon

#endif  // FLATBUFFERS_GENERATED_WEAPONTEXTFB_FBWEAPON_H_
