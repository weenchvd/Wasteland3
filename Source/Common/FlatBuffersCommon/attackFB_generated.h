// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ATTACKFB_FBATTACK_H_
#define FLATBUFFERS_GENERATED_ATTACKFB_FBATTACK_H_

#include "flatbuffers/flatbuffers.h"

namespace fbAttack {

struct FB_Attack;
struct FB_AttackBuilder;

enum FB_AttackType : int8_t {
  FB_AttackType_INVALID = 0,
  FB_AttackType_SINGLE_TARGET = 1,
  FB_AttackType_CHAIN_OF_SINGLE_TARGETS = 2,
  FB_AttackType_STRAIGHT_LINE = 3,
  FB_AttackType_CONICAL_AREA_BEHIND_TARGET = 4,
  FB_AttackType_CONICAL_AREA = 5,
  FB_AttackType_REMOTE_CIRCULAR_AREA = 6,
  FB_AttackType_CIRCULAR_AREA = 7,
  FB_AttackType_MIN = FB_AttackType_INVALID,
  FB_AttackType_MAX = FB_AttackType_CIRCULAR_AREA
};

inline const FB_AttackType (&EnumValuesFB_AttackType())[8] {
  static const FB_AttackType values[] = {
    FB_AttackType_INVALID,
    FB_AttackType_SINGLE_TARGET,
    FB_AttackType_CHAIN_OF_SINGLE_TARGETS,
    FB_AttackType_STRAIGHT_LINE,
    FB_AttackType_CONICAL_AREA_BEHIND_TARGET,
    FB_AttackType_CONICAL_AREA,
    FB_AttackType_REMOTE_CIRCULAR_AREA,
    FB_AttackType_CIRCULAR_AREA
  };
  return values;
}

inline const char * const *EnumNamesFB_AttackType() {
  static const char * const names[9] = {
    "INVALID",
    "SINGLE_TARGET",
    "CHAIN_OF_SINGLE_TARGETS",
    "STRAIGHT_LINE",
    "CONICAL_AREA_BEHIND_TARGET",
    "CONICAL_AREA",
    "REMOTE_CIRCULAR_AREA",
    "CIRCULAR_AREA",
    nullptr
  };
  return names;
}

inline const char *EnumNameFB_AttackType(FB_AttackType e) {
  if (flatbuffers::IsOutRange(e, FB_AttackType_INVALID, FB_AttackType_CIRCULAR_AREA)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFB_AttackType()[index];
}

struct FB_Attack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FB_AttackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTACK_TYPE = 4,
    VT_ATTACK_RANGE = 6,
    VT_RANGE_OF_BOUNCES = 8,
    VT_RANGE_OF_CONICAL_AREA = 10,
    VT_RADIUS_OF_CIRCULAR_AREA = 12,
    VT_QUANTITY_OF_BOUNCES = 14,
    VT_ANGLE_OF_CONICAL_AREA = 16
  };
  fbAttack::FB_AttackType attack_type() const {
    return static_cast<fbAttack::FB_AttackType>(GetField<int8_t>(VT_ATTACK_TYPE, 0));
  }
  int16_t attack_range() const {
    return GetField<int16_t>(VT_ATTACK_RANGE, 0);
  }
  int16_t range_of_bounces() const {
    return GetField<int16_t>(VT_RANGE_OF_BOUNCES, 0);
  }
  int16_t range_of_conical_area() const {
    return GetField<int16_t>(VT_RANGE_OF_CONICAL_AREA, 0);
  }
  int16_t radius_of_circular_area() const {
    return GetField<int16_t>(VT_RADIUS_OF_CIRCULAR_AREA, 0);
  }
  int16_t quantity_of_bounces() const {
    return GetField<int16_t>(VT_QUANTITY_OF_BOUNCES, 0);
  }
  int16_t angle_of_conical_area() const {
    return GetField<int16_t>(VT_ANGLE_OF_CONICAL_AREA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ATTACK_TYPE) &&
           VerifyField<int16_t>(verifier, VT_ATTACK_RANGE) &&
           VerifyField<int16_t>(verifier, VT_RANGE_OF_BOUNCES) &&
           VerifyField<int16_t>(verifier, VT_RANGE_OF_CONICAL_AREA) &&
           VerifyField<int16_t>(verifier, VT_RADIUS_OF_CIRCULAR_AREA) &&
           VerifyField<int16_t>(verifier, VT_QUANTITY_OF_BOUNCES) &&
           VerifyField<int16_t>(verifier, VT_ANGLE_OF_CONICAL_AREA) &&
           verifier.EndTable();
  }
};

struct FB_AttackBuilder {
  typedef FB_Attack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attack_type(fbAttack::FB_AttackType attack_type) {
    fbb_.AddElement<int8_t>(FB_Attack::VT_ATTACK_TYPE, static_cast<int8_t>(attack_type), 0);
  }
  void add_attack_range(int16_t attack_range) {
    fbb_.AddElement<int16_t>(FB_Attack::VT_ATTACK_RANGE, attack_range, 0);
  }
  void add_range_of_bounces(int16_t range_of_bounces) {
    fbb_.AddElement<int16_t>(FB_Attack::VT_RANGE_OF_BOUNCES, range_of_bounces, 0);
  }
  void add_range_of_conical_area(int16_t range_of_conical_area) {
    fbb_.AddElement<int16_t>(FB_Attack::VT_RANGE_OF_CONICAL_AREA, range_of_conical_area, 0);
  }
  void add_radius_of_circular_area(int16_t radius_of_circular_area) {
    fbb_.AddElement<int16_t>(FB_Attack::VT_RADIUS_OF_CIRCULAR_AREA, radius_of_circular_area, 0);
  }
  void add_quantity_of_bounces(int16_t quantity_of_bounces) {
    fbb_.AddElement<int16_t>(FB_Attack::VT_QUANTITY_OF_BOUNCES, quantity_of_bounces, 0);
  }
  void add_angle_of_conical_area(int16_t angle_of_conical_area) {
    fbb_.AddElement<int16_t>(FB_Attack::VT_ANGLE_OF_CONICAL_AREA, angle_of_conical_area, 0);
  }
  explicit FB_AttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FB_Attack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FB_Attack>(end);
    return o;
  }
};

inline flatbuffers::Offset<FB_Attack> CreateFB_Attack(
    flatbuffers::FlatBufferBuilder &_fbb,
    fbAttack::FB_AttackType attack_type = fbAttack::FB_AttackType_INVALID,
    int16_t attack_range = 0,
    int16_t range_of_bounces = 0,
    int16_t range_of_conical_area = 0,
    int16_t radius_of_circular_area = 0,
    int16_t quantity_of_bounces = 0,
    int16_t angle_of_conical_area = 0) {
  FB_AttackBuilder builder_(_fbb);
  builder_.add_angle_of_conical_area(angle_of_conical_area);
  builder_.add_quantity_of_bounces(quantity_of_bounces);
  builder_.add_radius_of_circular_area(radius_of_circular_area);
  builder_.add_range_of_conical_area(range_of_conical_area);
  builder_.add_range_of_bounces(range_of_bounces);
  builder_.add_attack_range(attack_range);
  builder_.add_attack_type(attack_type);
  return builder_.Finish();
}

}  // namespace fbAttack

#endif  // FLATBUFFERS_GENERATED_ATTACKFB_FBATTACK_H_
